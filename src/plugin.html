<plugin>
  <div class="plugin-content">
    <div class="title">Sounding forecast <span id="sounding-model"></span></div>
    <div id="sounding-chart"></div>
  </div>

  <script>
    import map from "@windy/map";
    import picker from "@windy/picker";
    import pluginDataLoader from "@windy/pluginDataLoader";
    import plugins from "@windy/plugins";
    import store from "@windy/store";

    import graph from "./soundingGraph.mjs";

    const options = {
      key: "QKlmnpLWr2rZSyFaT7LpxZc0d5bo34D4",
      plugin: "windy-plugin-sounding",
    };

    const load = pluginDataLoader(options);

    let marker = null;
    let prodSub;
    let pickerOpenSub;
    let pickerMoveSub;

    const meteogram = plugins["detail-render"].load().then(() => {
      W.define("sMeteogram", ["meteogram", "Class"], function(m, c) {
        return c.extend(m, {
          legend: () => this,
        });
      });
      return W.require("sMeteogram");
    });

    map.setZoom(10, { animate: false });
    store.set("overlay", "clouds");

    // Called when the plugin is opened
    // - `{lat, lon}` when opened from the context menu,
    // - `{lat, lon, name, ...}` when open from a favorite,
    // - `undefined` when opened in dev mode on plugin reload.
    this.onopen = location => {
      let lat;
      let lon;

      // Opening from other location than contextmenu
      if (!location) {
        const c = map.getCenter();
        lat = c.lat;
        lon = c.lng;
      } else {
        lat = location.lat;
        lon = location.lon;
      }

      const bounds = map.getBounds();
      const deltaLng = bounds.getEast() - bounds.getWest();
      // TODO: 300 = left bar width / 2
      const centerLon = lon - (deltaLng / map.getSize().x) * 300;
      map.panTo({ lng: centerLon, lat });

      graph.init(lat, lon);
      loadData(lat, lon);
      cancelSubscriptions();
      prodSub = store.on("product", () => loadData(lat, lon));
      pickerOpenSub = picker.on("pickerOpened", ({ lat, lon }) => loadData(lat, lon));
      pickerMoveSub = picker.on("pickerMoved", ({ lat, lon }) => loadData(lat, lon));

      this.node.oncontextmenu = this.node.ondblclick = this.node.onclick = ev =>
        ev.stopPropagation();
    };

    const loadData = (lat, lon) => {
      moveMarkerTo(lat, lon);
      const supportedModels = /gfs|ecmwf|nam\w+|iconEu/;
      let model = store.get("product");
      if (!supportedModels.test(model)) {
        // fallback to ecmwf if the model is not supported
        model = "ecmwf";
      }

      document.getElementById("sounding-model").innerText = model.toUpperCase();

      const dataOptions = { model, lat, lon };

      Promise.all([load("airData", dataOptions), load("forecast", dataOptions), meteogram]).then(
        ([airData, forecast, meteogram]) => {
          graph.load(airData.data, forecast.data, meteogram);
        }
      );
    };

    // Called when closed
    this.onclose = () => {
      cancelSubscriptions();
      if (marker) {
        map.removeLayer(marker);
        marker = null;
      }
    };

    function cancelSubscriptions() {
      if (prodSub) {
        store.off(prodSub);
        prodSub = null;
      }
      if (pickerOpenSub) {
        picker.off(pickerOpenSub);
        pickerOpenSub = null;
      }

      if (pickerMoveSub) {
        picker.off(pickerMoveSub);
        pickerMoveSub = null;
      }
    }

    function moveMarkerTo(lat, lon) {
      const leafletCoords = { lng: lon, lat };
      if (marker) {
        marker.setLatLng(leafletCoords);
      } else {
        marker = L.marker(leafletCoords, {
          icon: map.myMarkers.pulsatingIcon,
          zIndexOffset: -300,
        }).addTo(map);
      }
    }
  </script>
</plugin>
